스프링은 DI, DI 컨테이너 제공을 통해 다형성, OCP, DIP 원칙 제공
좋은 객체 지향 설계: 역할과 구현을 분리, 이상적으로 모든 설계에 인터페이스 부여
(바뀌는 기술에 빠르게 대응 가능)
but, 인터페이스를 도입하면 추상화 비용 발생

1. IoC (Inversion of Control) = 제어의 역전
스프링 컨테이너가 빈의 생성, 의존 관계 설정 등의 작업을 코드 대신에 담당한다.
즉, 스프링 컨테이너가 오브젝트(빈)에 대한 제어권을 갖고 있다.

2. DI (Dependency Injection) = 의존 관계 주입
의존 대상 B가 변하면, 그것이 A에 영향을 미친다 - 토비의 스프링
의존 관계를 외부(IoC 컨테이너)에서 결정하는 것을 DI라고 한다.
@Autowired를 이용하여 필드, 수정자, 생성자(권장) 주입을 통해 구현한다.

빈은 Configuration metadata로 설정 값을 등록할 수 있다.

//기타 - 웹 환경에서 스프링 애플리케이션이 동작하는 방식 (스프링부트X)
클라이언트 http 요청
-> 서블릿 컨테이너의 DispatcherServlet에서 등록된 빈 메소드 호출
(request mapping)
(서비스 계층, 데이터 엑세스 계층은 어노테이션으로 구분 - 3계층 아키텍쳐)
springMVC는 프레젠테이션 계층에서 동작한다. (Controller 포함)
서비스 계층에서는 비즈니스 도메인, 데이터 엑세스 계층은 DB 접근
(그래서 각 계층에 맞게 Controller, Service, DAO를 나누어야 변경 용이)

entity 제작 시, 최대한 setter를 사용하지 말고 메소드(특정 행위)를 통해서 상태를 변하게 하도록 할것